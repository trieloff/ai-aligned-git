#!/bin/bash

# Git wrapper - Automatically detect AI tools and use appropriate commit attribution
# Uses am-i-ai shared detection library
# See: https://github.com/trieloff/am-i-ai

# --- BEGIN BUNDLED am-i-ai ---
# Bundled from am-i-ai (https://github.com/trieloff/am-i-ai)
# This section is automatically updated by the propagate-updates workflow

# Version of the am-i-ai library
AMI_VERSION="1.0.0"

# Debug mode - set AMI_DEBUG=true to enable
AMI_DEBUG="${AMI_DEBUG:-false}"

# Internal debug logging function
_ami_debug() {
    if [ "$AMI_DEBUG" = "true" ]; then
        echo "[am-i-ai] $*" >&2
    fi
}

# Function to check if a process name contains a pattern (case-insensitive)
# Arguments: $1 = pid, $2 = pattern
# Returns: 0 if pattern found, 1 otherwise
ami_process_contains() {
    local pid=$1
    local pattern=$2

    # Get process command and name
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        # Linux
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}

# Phase 1: Environment variable detection
# Returns space-separated list of detected AI tools
ami_check_env() {
    local detected=""

    # Claude Code detection
    # Detect via CLAUDECODE or CLAUDE_CODE_ENTRYPOINT env vars
    # ACP mode sets CLAUDECODE=1 without CLAUDE_CODE_ENTRYPOINT
    # CLI/SDK mode sets both CLAUDECODE and CLAUDE_CODE_ENTRYPOINT
    if [ -n "$CLAUDECODE" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "cli" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "sdk-ts" ]; then
        detected="$detected claude"
        _ami_debug "Detected Claude via environment variable"
    fi

    # Gemini detection
    if [ -n "$GEMINI_CLI" ]; then
        detected="$detected gemini"
        _ami_debug "Detected Gemini via environment variable"
    fi

    # Qwen detection
    if [ -n "$QWEN_CODE" ]; then
        detected="$detected qwen"
        _ami_debug "Detected Qwen via environment variable"
    fi

    # Cursor detection
    if [ -n "$CURSOR_AI" ]; then
        detected="$detected cursor"
        _ami_debug "Detected Cursor via environment variable"
    fi

    # OpenCode detection
    if [ -n "$OPENCODE_AI" ]; then
        detected="$detected opencode"
        _ami_debug "Detected OpenCode via environment variable"
    fi

    # Codex CLI detection
    # Detect via CODEX_CLI env var or CODEX_SANDBOX (set in sandboxed ACP sessions)
    if [ -n "$CODEX_CLI" ] || [ -n "$CODEX_SANDBOX" ]; then
        detected="$detected codex"
        _ami_debug "Detected Codex via environment variable"
    fi

    # Aider detection
    if [ "$OR_APP_NAME" = "Aider" ]; then
        detected="$detected aider"
        _ami_debug "Detected Aider via environment variable"
    fi

    # Zed detection - complex logic to distinguish human from AI
    # Observed patterns:
    # 1. Human via git panel: ZED_ENVIRONMENT + NO terminal vars + SHLVL=1
    # 2. Human via terminal: ZED_ENVIRONMENT + parent is interactive shell (elvish, zsh, bash, fish)
    # 3. Zed's native agent: ZED_ENVIRONMENT + HAS terminal vars + SHLVL>1 + parent NOT interactive shell
    # 4. ACP integrations: Have their own tool markers (handled above)
    #
    # Key insight: If the direct parent process is an interactive shell,
    # the user is typing commands manually, not the Zed agent.
    local term_program_lower
    term_program_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
    if [ -n "$ZED_ENVIRONMENT" ]; then
        if { [ "$term_program_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
            # Has terminal vars and SHLVL>1 - could be agent or human in terminal
            # Check if parent process is an interactive shell (human typing)
            local parent_comm
            parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
            case "$parent_comm" in
                bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                    # Parent is interactive shell - human typing in terminal
                    _ami_debug "Zed detected but parent is interactive shell ($parent_comm) - human typing"
                    ;;
                *)
                    # Parent is not an interactive shell - likely Zed agent
                    detected="$detected zed"
                    _ami_debug "Detected Zed AI agent via environment (parent: $parent_comm)"
                    ;;
            esac
        fi
        # else: Human git panel (SHLVL=1, no terminal vars)
    fi

    # Copilot detection
    if [ "$GITHUB_COPILOT_CLI_MODE" = "true" ]; then
        detected="$detected copilot"
        _ami_debug "Detected Copilot via environment variable"
    fi

    # Droid detection (Factory AI)
    if [ -n "$DROID_CLI" ]; then
        detected="$detected droid"
        _ami_debug "Detected Droid via environment variable"
    fi

    # Amp detection (Sourcegraph)
    if [ "$AGENT" = "amp" ] || [ -n "$AMP_HOME" ]; then
        detected="$detected amp"
        _ami_debug "Detected Amp via environment variable"
    fi

    # Kimi CLI detection
    if [ -n "$KIMI_CLI" ]; then
        detected="$detected kimi"
        _ami_debug "Detected Kimi CLI via environment variable"
    fi

    # OpenHands detection
    if [ "$OR_APP_NAME" = "OpenHands" ] || [ -n "$OR_SITE_URL" ]; then
        detected="$detected openhands"
        _ami_debug "Detected OpenHands via environment variable"
    fi

    # Goose detection (Block)
    if [ -n "$GOOSE_TERMINAL" ]; then
        detected="$detected goose"
        _ami_debug "Detected Goose via environment variable"
    fi

    # Auggie detection (Augment Code)
    if [ -n "$AUGMENT_API_TOKEN" ]; then
        detected="$detected auggie"
        _ami_debug "Detected Auggie via environment variable"
    fi

    # Cline detection (VS Code extension)
    if [ -n "$CLINE_TASK_ID" ]; then
        detected="$detected cline"
        _ami_debug "Detected Cline via environment variable"
    fi

    # Roo Code detection (VS Code extension)
    if [ -n "$ROO_CODE_TASK_ID" ]; then
        detected="$detected roo"
        _ami_debug "Detected Roo Code via environment variable"
    fi

    # Windsurf/Cascade detection
    if [ -n "$WINDSURF_SESSION" ] || [ "$TERM_PROGRAM" = "windsurf" ]; then
        detected="$detected windsurf"
        _ami_debug "Detected Windsurf via environment variable"
    fi

    echo "$detected"
}

# Phase 2: Process tree detection
# Returns space-separated list of detected AI tools
ami_check_ps_tree() {
    local detected=""
    local current_pid=$$
    local max_depth=10
    local depth=0

    _ami_debug "Starting process tree detection from PID $current_pid"

    while [ $depth -lt $max_depth ]; do
        # Get parent PID
        if [[ "$OSTYPE" == "darwin"* ]]; then
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        else
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        fi

        # Check if we've reached the top
        if [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ]; then
            _ami_debug "Reached top of process tree at depth $depth"
            break
        fi

        _ami_debug "Checking PID $current_pid at depth $depth"

        # Check for AI tool patterns
        if ami_process_contains "$current_pid" "claude"; then
            detected="$detected claude"
            _ami_debug "Detected Claude in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "gemini"; then
            detected="$detected gemini"
            _ami_debug "Detected Gemini in process tree at depth $depth"
        fi
        # Detect Codex CLI by process name
        if ami_process_contains "$current_pid" "codex"; then
            detected="$detected codex"
            _ami_debug "Detected Codex in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "aider"; then
            detected="$detected aider"
            _ami_debug "Detected Aider in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "qwen"; then
            detected="$detected qwen"
            _ami_debug "Detected Qwen in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "zed"; then
            # Attribute to Zed's native agent when terminal vars ARE set and SHLVL > 1
            # BUT not if parent is an interactive shell (human typing)
            local tp_lower
            tp_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
            if { [ "$tp_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
                local parent_comm
                parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
                case "$parent_comm" in
                    bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                        # Parent is interactive shell - human typing
                        _ami_debug "Zed in tree but parent is interactive shell - human typing"
                        ;;
                    *)
                        detected="$detected zed"
                        _ami_debug "Detected Zed AI in process tree at depth $depth"
                        ;;
                esac
            fi
        fi
        if ami_process_contains "$current_pid" "opencode"; then
            detected="$detected opencode"
            _ami_debug "Detected OpenCode in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "cursor"; then
            detected="$detected cursor"
            _ami_debug "Detected Cursor in process tree at depth $depth"
        fi
        # Kimi CLI detection - look for kimi in process command
        if ami_process_contains "$current_pid" "kimi"; then
            detected="$detected kimi"
            _ami_debug "Detected Kimi CLI in process tree at depth $depth"
        fi
        # Crush detection - look for crush in process command
        if ami_process_contains "$current_pid" "crush"; then
            detected="$detected crush"
            _ami_debug "Detected Crush in process tree at depth $depth"
        fi
        # Goose detection - look for goose in process command
        if ami_process_contains "$current_pid" "goose"; then
            detected="$detected goose"
            _ami_debug "Detected Goose in process tree at depth $depth"
        fi
        # Auggie detection - look for auggie in process command
        if ami_process_contains "$current_pid" "auggie"; then
            detected="$detected auggie"
            _ami_debug "Detected Auggie in process tree at depth $depth"
        fi
        # Cline detection
        if ami_process_contains "$current_pid" "cline"; then
            detected="$detected cline"
            _ami_debug "Detected Cline in process tree at depth $depth"
        fi
        # Roo Code detection
        if ami_process_contains "$current_pid" "roo"; then
            detected="$detected roo"
            _ami_debug "Detected Roo Code in process tree at depth $depth"
        fi
        # Windsurf detection
        if ami_process_contains "$current_pid" "windsurf"; then
            detected="$detected windsurf"
            _ami_debug "Detected Windsurf in process tree at depth $depth"
        fi
        # Droid detection - use word boundary to avoid matching android-studio, etc.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                _ami_debug "Detected Droid in process tree at depth $depth"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                _ami_debug "Detected Droid in process tree at depth $depth"
            fi
        fi

        depth=$((depth + 1))
    done

    echo "$detected"
}

# Main AI detection function with proper two-phase approach
# Returns the detected AI tool name, or "none" if no AI detected
# Priority order ensures more specific tools take precedence over generic ones
ami_detect() {
    _ami_debug "Starting AI detection"

    # Phase 1: Environment variable detection
    local env_detected
    env_detected=$(ami_check_env)

    # Phase 2: Process tree detection
    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    # Combine results and apply priority order
    local all_detected="$env_detected $ps_detected"

    _ami_debug "Environment detected: '$env_detected'"
    _ami_debug "Process tree detected: '$ps_detected'"
    _ami_debug "Combined detected: '$all_detected'"

    # Priority order: Amp > Codex > Aider > Claude > Gemini > Qwen > Droid > OpenCode > Cursor > Copilot > Kimi > OpenHands > Cline > Roo > Windsurf > Crush > Goose > Auggie > Zed
    # Zed is last because it often hosts other AI tools
    # More specific AI tools take precedence over IDE-level tools
    if [[ "$all_detected" =~ "amp" ]]; then
        _ami_debug "Final result: amp"
        echo "amp"
    elif [[ "$all_detected" =~ "codex" ]]; then
        _ami_debug "Final result: codex"
        echo "codex"
    elif [[ "$all_detected" =~ "aider" ]]; then
        _ami_debug "Final result: aider"
        echo "aider"
    elif [[ "$all_detected" =~ "claude" ]]; then
        _ami_debug "Final result: claude"
        echo "claude"
    elif [[ "$all_detected" =~ "gemini" ]]; then
        _ami_debug "Final result: gemini"
        echo "gemini"
    elif [[ "$all_detected" =~ "qwen" ]]; then
        _ami_debug "Final result: qwen"
        echo "qwen"
    elif [[ "$all_detected" =~ "droid" ]]; then
        _ami_debug "Final result: droid"
        echo "droid"
    elif [[ "$all_detected" =~ "opencode" ]]; then
        _ami_debug "Final result: opencode"
        echo "opencode"
    elif [[ "$all_detected" =~ "cursor" ]]; then
        _ami_debug "Final result: cursor"
        echo "cursor"
    elif [[ "$all_detected" =~ "copilot" ]]; then
        _ami_debug "Final result: copilot"
        echo "copilot"
    elif [[ "$all_detected" =~ "kimi" ]]; then
        _ami_debug "Final result: kimi"
        echo "kimi"
    elif [[ "$all_detected" =~ "openhands" ]]; then
        _ami_debug "Final result: openhands"
        echo "openhands"
    elif [[ "$all_detected" =~ "cline" ]]; then
        _ami_debug "Final result: cline"
        echo "cline"
    elif [[ "$all_detected" =~ "roo" ]]; then
        _ami_debug "Final result: roo"
        echo "roo"
    elif [[ "$all_detected" =~ "windsurf" ]]; then
        _ami_debug "Final result: windsurf"
        echo "windsurf"
    elif [[ "$all_detected" =~ "crush" ]]; then
        _ami_debug "Final result: crush"
        echo "crush"
    elif [[ "$all_detected" =~ "goose" ]]; then
        _ami_debug "Final result: goose"
        echo "goose"
    elif [[ "$all_detected" =~ "auggie" ]]; then
        _ami_debug "Final result: auggie"
        echo "auggie"
    elif [[ "$all_detected" =~ "zed" ]]; then
        _ami_debug "Final result: zed"
        echo "zed"
    else
        _ami_debug "Final result: none"
        echo "none"
    fi
}

# Convenience function: returns 0 (true) if AI is detected, 1 (false) otherwise
ami_is_ai() {
    local result
    result=$(ami_detect)
    [ "$result" != "none" ]
}

# Get all detected AI tools (not just the highest priority one)
# Returns space-separated list or empty string
ami_detect_all() {
    local env_detected
    env_detected=$(ami_check_env)

    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    # Combine and deduplicate
    local all_detected="$env_detected $ps_detected"

    # Remove leading/trailing spaces and deduplicate
    echo "$all_detected" | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//'
}

# Get the email address for a detected AI tool
# Arguments: $1 = AI tool name (optional, uses ami_detect if not provided)
ami_get_email() {
    local tool="${1:-$(ami_detect)}"

    case "$tool" in
        "claude")   echo "noreply@anthropic.com" ;;
        "gemini")   echo "noreply@google.com" ;;
        "codex")    echo "noreply@openai.com" ;;
        "aider")    echo "aider@aider.chat" ;;
        "qwen")     echo "noreply@alibaba.com" ;;
        "cursor")   echo "cursoragent@cursor.com" ;;
        "opencode") echo "noreply@opencode.ai" ;;
        "zed")      echo "noreply@zed.dev" ;;
        "copilot")  echo "copilot@github.com" ;;
        "droid")    echo "droid@factory.ai" ;;
        "amp")      echo "noreply@sourcegraph.com" ;;
        "kimi")     echo "noreply@kimi.com" ;;
        "openhands") echo "openhands@all-hands.dev" ;;
        "crush")    echo "crush@charm.land" ;;
        "goose")    echo "goose@opensource.block.xyz" ;;
        "auggie")   echo "noreply@augmentcode.com" ;;
        "cline")    echo "cline@cline.bot" ;;
        "roo")      echo "roo@roocode.dev" ;;
        "windsurf") echo "cascade@codeium.com" ;;
        *)          echo "" ;;
    esac
}

# Get the display name for a detected AI tool
# Arguments: $1 = AI tool name (optional, uses ami_detect if not provided)
ami_get_name() {
    local tool="${1:-$(ami_detect)}"

    case "$tool" in
        "claude")   echo "Claude Code" ;;
        "gemini")   echo "Gemini" ;;
        "codex")    echo "Codex CLI" ;;
        "aider")    echo "Aider" ;;
        "qwen")     echo "Qwen Code" ;;
        "cursor")   echo "Cursor AI" ;;
        "opencode") echo "opencode AI" ;;
        "zed")      echo "Zed AI" ;;
        "copilot")  echo "GitHub Copilot" ;;
        "droid")    echo "Droid" ;;
        "amp")      echo "Amp" ;;
        "kimi")     echo "Kimi CLI" ;;
        "openhands") echo "OpenHands" ;;
        "crush")    echo "Crush" ;;
        "goose")    echo "Goose User" ;;
        "auggie")   echo "Augment Code" ;;
        "cline")    echo "Cline" ;;
        "roo")      echo "Roo Code" ;;
        "windsurf") echo "Windsurf Cascade" ;;
        *)          echo "" ;;
    esac
}

# Print version information
ami_version() {
    echo "am-i-ai version $AMI_VERSION"
    echo "https://github.com/trieloff/am-i-ai"
}

# If this script is run directly (not sourced), run the detection

# Map am-i-ai function names to local conventions
process_contains() { ami_process_contains "$@"; }
check_env_vars() { ami_check_env; }
check_ps_tree() { ami_check_ps_tree; }
detect_ai_tool() { ami_detect; }

# --- END BUNDLED am-i-ai ---

# Find the real git executable
find_real_git() {
    # Common locations for git
    local git_paths=(
        "/usr/bin/git"
        "/usr/local/bin/git"
        "/opt/homebrew/bin/git"
        "/opt/local/bin/git"
    )

    for git_path in "${git_paths[@]}"; do
        if [ -x "$git_path" ]; then
            echo "$git_path"
            return
        fi
    done

    # If not found in common locations, search PATH excluding our own directory
    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/git" ]; then
            echo "$dir/git"
            return
        fi
    done

    echo "git not found" >&2
    exit 1
}

# Main script
GIT_BIN=$(find_real_git)

# Function to get configured git user for signoff
get_git_signoff() {
    local mode="${1:-signoff}"  # "signoff" or "disapprove"
    local git_name
    local git_email
    git_name=$("$GIT_BIN" config user.name 2>/dev/null)
    git_email=$("$GIT_BIN" config user.email 2>/dev/null)

    if [ "$mode" = "disapprove" ]; then
        if [ -n "$git_name" ] && [ -n "$git_email" ]; then
            echo "Grudgingly-Disapproved-By: $git_name <$git_email>"
        else
            echo "Grudgingly-Disapproved-By: Unknown User <unknown@example.com>"
        fi
    else
        if [ -n "$git_name" ] && [ -n "$git_email" ]; then
            echo "Signed-off-by: $git_name <$git_email>"
        else
            echo "Signed-off-by: Unknown User <unknown@example.com>"
        fi
    fi
}

# Function to show files that would be added
show_files_to_add() {
    local add_type="$1"  # "all" or "current"

    echo "Files that would be added:" >&2

    if [ "$add_type" = "all" ]; then
        # Show all modified, new, and deleted files (equivalent to git add -A)
        "$GIT_BIN" status --porcelain 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                # Extract filename (everything after the status codes)
                filename=$(echo "$line" | cut -c4-)
                echo "  $filename" >&2
            fi
        done
    else
        # Show files in current directory and subdirectories (equivalent to git add .)
        "$GIT_BIN" status --porcelain . 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                # Extract filename (everything after the status codes)
                filename=$(echo "$line" | cut -c4-)
                echo "  $filename" >&2
            fi
        done
    fi

    echo "" >&2
    echo "Instead, add files individually:" >&2

    # Show the command to add them individually
    if [ "$add_type" = "all" ]; then
        "$GIT_BIN" status --porcelain 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  git add $(printf '%q' "$filename")" >&2
            fi
        done
    else
        "$GIT_BIN" status --porcelain . 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  git add $(printf '%q' "$filename")" >&2
            fi
        done
    fi
}

# Check if this is an add command and we're in an AI context
if [ "$1" = "add" ]; then
    # Detect AI tool
    ai_tool=$(detect_ai_tool)

    if [ "$ai_tool" != "none" ]; then
        # Check for dangerous add patterns
        # Look for -- separator to determine if files are explicitly specified
        has_separator=false
        has_files_after_separator=false
        separator_found=false

        for arg in "$@"; do
            if [ "$separator_found" = true ]; then
                # We found arguments after --, so files are explicitly specified
                has_files_after_separator=true
                break
            elif [ "$arg" = "--" ]; then
                has_separator=true
                separator_found=true
            fi
        done

        # Check each argument for dangerous patterns
        for arg in "$@"; do
            if [ "$arg" = "-A" ] || [ "$arg" = "--all" ]; then
                # Allow -A/--all if files are explicitly specified after --
                if [ "$has_separator" = true ] && [ "$has_files_after_separator" = true ]; then
                    continue  # This is safe: git add -A -- specific-file
                else
                    echo "Error: 'git add $arg' is not allowed when running under AI control ($ai_tool)." >&2
                    echo "For safety, AI tools must add files individually by specifying each file path." >&2
                    echo "" >&2
                    show_files_to_add "all"
                    echo "" >&2
                    echo "Or use: git add $arg -- specific-file" >&2
                    exit 1
                fi
            elif [ "$arg" = "." ]; then
                echo "Error: 'git add $arg' is not allowed when running under AI control ($ai_tool)." >&2
                echo "For safety, AI tools must add files individually by specifying each file path." >&2
                echo "" >&2
                show_files_to_add "current"
                exit 1
            fi
        done
    fi

    # If we get here, the add command is safe - pass through to regular git
    exec "$GIT_BIN" "$@"
fi

# Check if this is a commit command
if [ "$1" = "commit" ]; then
    # Detect AI tool
    ai_tool=$(detect_ai_tool)

    # Check for --no-verify bypass attempts by AI tools
    if [ "$ai_tool" != "none" ]; then
        has_no_verify=false
        has_lazy_cheater_flag=false

        for arg in "$@"; do
            if [ "$arg" = "--no-verify" ] || [ "$arg" = "-n" ]; then
                has_no_verify=true
            elif [ "$arg" = "--${ai_tool}-is-a-lazy-cheater" ]; then
                has_lazy_cheater_flag=true
            fi
        done

        if [ "$has_no_verify" = true ] && [ "$has_lazy_cheater_flag" = false ]; then
            echo "Error: '$ai_tool' is trying to bypass commit hooks with --no-verify!" >&2
            echo "This is not allowed for AI tools as it circumvents important safety checks." >&2
            echo "" >&2
            echo "If you really need to bypass hooks, add the flag: --${ai_tool}-is-a-lazy-cheater" >&2
            echo "This will publicly shame the AI for being lazy about following proper procedures." >&2
            exit 1
        fi
    fi

    # Build git command with appropriate author settings using am-i-ai library
    # This automatically supports all AI tools defined in am-i-ai
    ai_name=$(ami_get_name "$ai_tool")
    ai_email=$(ami_get_email "$ai_tool")

    if [ -n "$ai_name" ] && [ -n "$ai_email" ]; then
        extra_args=(
            -c "user.name=$ai_name"
            -c "user.email=$ai_email"
            -c "commit.gpgsign=false"
        )
        if [ "$has_lazy_cheater_flag" = true ]; then
            signoff=$(get_git_signoff "disapprove")
        else
            signoff=$(get_git_signoff)
        fi
    else
        # Unknown AI tool or no attribution info - pass through to regular git
        exec "$GIT_BIN" "$@"
    fi

    # If we detected an AI tool, we need to handle the commit specially
    shift  # Remove "commit" from arguments

    # Parse commit arguments to find -m flag
    commit_args=()
    message_found=false
    skip_next=false

    for arg in "$@"; do
        # Skip the lazy cheater flag - git doesn't understand it
        if [ "$ai_tool" != "none" ] && [ "$arg" = "--${ai_tool}-is-a-lazy-cheater" ]; then
            continue
        fi

        if [ "$skip_next" = true ]; then
            # This is the message content after -m
            if [ "$ai_tool" != "none" ] && [ "$has_lazy_cheater_flag" = true ]; then
                commit_args+=("$arg

?? SHAME: This commit was made by $ai_tool who was too lazy to fix the commit hooks properly.")
            else
                commit_args+=("$arg")
            fi
            commit_args+=(-m "$signoff")
            skip_next=false
            message_found=true
        elif [ "$arg" = "-m" ] || [ "$arg" = "--message" ]; then
            commit_args+=("$arg")
            skip_next=true
        else
            commit_args+=("$arg")
        fi
    done

    # If no message was provided with -m, add signoff using commit template
    if [ "$message_found" = false ]; then
        # Create temporary file for commit message template
        tmpfile=$(mktemp)
        if [ "$ai_tool" != "none" ] && [ "$has_lazy_cheater_flag" = true ]; then
            echo "

?? SHAME: This commit was made by $ai_tool who was too lazy to fix the commit hooks properly." >> "$tmpfile"
        fi
        echo "" >> "$tmpfile"
        if [ "$has_lazy_cheater_flag" = true ]; then
            signoff=$(get_git_signoff "disapprove")
        fi
        echo "$signoff" >> "$tmpfile"
        commit_args+=(--template "$tmpfile")

        # Run git commit and clean up
        "$GIT_BIN" "${extra_args[@]}" commit "${commit_args[@]}"
        exit_code=$?
        rm -f "$tmpfile"
        exit $exit_code
    else
        # Run git commit with modified arguments
        exec "$GIT_BIN" "${extra_args[@]}" commit "${commit_args[@]}"
    fi
else
    # Not a commit command, pass through to regular git
    exec "$GIT_BIN" "$@"
fi

#!/bin/bash

# Git wrapper - Automatically detect AI tools and use appropriate commit attribution
# AI detection powered by am-i-ai: https://github.com/trieloff/am-i-ai

# --- BEGIN BUNDLED am-i-ai ---
# Bundled from am-i-ai v1.0.0
# https://github.com/trieloff/am-i-ai
#
# This code is auto-generated. Do not edit manually.
# To update, run the propagate-updates workflow in am-i-ai.

# Internal debug logging function
_ami_debug() {
    if [ "${AMI_DEBUG:-false}" = "true" ]; then
        echo "[am-i-ai] $*" >&2
    fi
}

# Function to check if a process name contains a pattern (case-insensitive)
ami_process_contains() {
    local pid=$1
    local pattern=$2

    if [[ "$OSTYPE" == "darwin"* ]]; then
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}

# Phase 1: Environment variable detection
ami_check_env() {
    local detected=""

    # Claude Code detection
    if [ -n "$CLAUDECODE" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "cli" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "sdk-ts" ]; then
        detected="$detected claude"
    fi

    # Gemini detection
    if [ -n "$GEMINI_CLI" ]; then
        detected="$detected gemini"
    fi

    # Qwen detection
    if [ -n "$QWEN_CODE" ]; then
        detected="$detected qwen"
    fi

    # Cursor detection
    if [ -n "$CURSOR_AI" ]; then
        detected="$detected cursor"
    fi

    # OpenCode detection
    if [ -n "$OPENCODE_AI" ]; then
        detected="$detected opencode"
    fi

    # Codex CLI detection
    if [ -n "$CODEX_CLI" ] || [ -n "$CODEX_SANDBOX" ]; then
        detected="$detected codex"
    fi

    # Aider detection
    if [ "$OR_APP_NAME" = "Aider" ]; then
        detected="$detected aider"
    fi

    # Zed detection - distinguish human from AI
    local term_program_lower
    term_program_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
    if [ -n "$ZED_ENVIRONMENT" ]; then
        if { [ "$term_program_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
            local parent_comm
            parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
            case "$parent_comm" in
                bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                    ;;
                *)
                    detected="$detected zed"
                    ;;
            esac
        fi
    fi

    # Copilot detection
    if [ "$GITHUB_COPILOT_CLI_MODE" = "true" ]; then
        detected="$detected copilot"
    fi

    # Droid detection
    if [ -n "$DROID_CLI" ]; then
        detected="$detected droid"
    fi

    # Amp detection
    if [ "$AGENT" = "amp" ] || [ -n "$AMP_HOME" ]; then
        detected="$detected amp"
    fi

    # Kimi CLI detection
    if [ -n "$KIMI_CLI" ]; then
        detected="$detected kimi"
    fi

    # OpenHands detection
    if [ "$OR_APP_NAME" = "OpenHands" ] || [ -n "$OR_SITE_URL" ]; then
        detected="$detected openhands"
    fi

    # Goose detection
    if [ -n "$GOOSE_TERMINAL" ]; then
        detected="$detected goose"
    fi

    # Cline detection
    if [ -n "$CLINE_TASK_ID" ]; then
        detected="$detected cline"
    fi

    # Roo Code detection
    if [ -n "$ROO_CODE_TASK_ID" ]; then
        detected="$detected roo"
    fi

    # Windsurf detection
    if [ -n "$WINDSURF_SESSION" ] || [ "$TERM_PROGRAM" = "windsurf" ]; then
        detected="$detected windsurf"
    fi

    echo "$detected"
}

# Phase 2: Process tree detection
ami_check_ps_tree() {
    local detected=""
    local current_pid=$$
    local max_depth=10
    local depth=0

    while [ $depth -lt $max_depth ]; do
        current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')

        if [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ]; then
            break
        fi

        if ami_process_contains "$current_pid" "claude"; then
            detected="$detected claude"
        fi
        if ami_process_contains "$current_pid" "gemini"; then
            detected="$detected gemini"
        fi
        if ami_process_contains "$current_pid" "codex"; then
            detected="$detected codex"
        fi
        if ami_process_contains "$current_pid" "aider"; then
            detected="$detected aider"
        fi
        if ami_process_contains "$current_pid" "qwen"; then
            detected="$detected qwen"
        fi
        if ami_process_contains "$current_pid" "zed"; then
            local tp_lower
            tp_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
            if { [ "$tp_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
                local parent_comm
                parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
                case "$parent_comm" in
                    bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                        ;;
                    *)
                        detected="$detected zed"
                        ;;
                esac
            fi
        fi
        if ami_process_contains "$current_pid" "opencode"; then
            detected="$detected opencode"
        fi
        if ami_process_contains "$current_pid" "cursor"; then
            detected="$detected cursor"
        fi
        if ami_process_contains "$current_pid" "kimi"; then
            detected="$detected kimi"
        fi
        if ami_process_contains "$current_pid" "crush"; then
            detected="$detected crush"
        fi
        if ami_process_contains "$current_pid" "goose"; then
            detected="$detected goose"
        fi
        if ami_process_contains "$current_pid" "cline"; then
            detected="$detected cline"
        fi
        if ami_process_contains "$current_pid" "roo"; then
            detected="$detected roo"
        fi
        if ami_process_contains "$current_pid" "windsurf"; then
            detected="$detected windsurf"
        fi
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
            fi
        fi

        depth=$((depth + 1))
    done

    echo "$detected"
}

# Main AI detection function
ami_detect() {
    local env_detected
    env_detected=$(ami_check_env)

    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    local all_detected="$env_detected $ps_detected"

    # Priority order
    if [[ "$all_detected" =~ "amp" ]]; then
        echo "amp"
    elif [[ "$all_detected" =~ "codex" ]]; then
        echo "codex"
    elif [[ "$all_detected" =~ "aider" ]]; then
        echo "aider"
    elif [[ "$all_detected" =~ "claude" ]]; then
        echo "claude"
    elif [[ "$all_detected" =~ "gemini" ]]; then
        echo "gemini"
    elif [[ "$all_detected" =~ "qwen" ]]; then
        echo "qwen"
    elif [[ "$all_detected" =~ "droid" ]]; then
        echo "droid"
    elif [[ "$all_detected" =~ "opencode" ]]; then
        echo "opencode"
    elif [[ "$all_detected" =~ "cursor" ]]; then
        echo "cursor"
    elif [[ "$all_detected" =~ "copilot" ]]; then
        echo "copilot"
    elif [[ "$all_detected" =~ "kimi" ]]; then
        echo "kimi"
    elif [[ "$all_detected" =~ "openhands" ]]; then
        echo "openhands"
    elif [[ "$all_detected" =~ "cline" ]]; then
        echo "cline"
    elif [[ "$all_detected" =~ "roo" ]]; then
        echo "roo"
    elif [[ "$all_detected" =~ "windsurf" ]]; then
        echo "windsurf"
    elif [[ "$all_detected" =~ "crush" ]]; then
        echo "crush"
    elif [[ "$all_detected" =~ "goose" ]]; then
        echo "goose"
    elif [[ "$all_detected" =~ "zed" ]]; then
        echo "zed"
    else
        echo "none"
    fi
}

# Function aliases for backward compatibility
process_contains() { ami_process_contains "$@"; }
check_env_vars() { ami_check_env; }
check_ps_tree() { ami_check_ps_tree; }
detect_ai_tool() { ami_detect; }
# --- END BUNDLED am-i-ai ---

# Find the real git executable
find_real_git() {
    local git_paths=(
        "/usr/bin/git"
        "/usr/local/bin/git"
        "/opt/homebrew/bin/git"
        "/opt/local/bin/git"
    )

    for git_path in "${git_paths[@]}"; do
        if [ -x "$git_path" ]; then
            echo "$git_path"
            return
        fi
    done

    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/git" ]; then
            echo "$dir/git"
            return
        fi
    done

    echo "git not found" >&2
    exit 1
}

# Main script
GIT_BIN=$(find_real_git)

# Function to get configured git user for signoff
get_git_signoff() {
    local mode="${1:-signoff}"
    local git_name
    local git_email
    git_name=$("$GIT_BIN" config user.name 2>/dev/null)
    git_email=$("$GIT_BIN" config user.email 2>/dev/null)

    if [ "$mode" = "disapprove" ]; then
        if [ -n "$git_name" ] && [ -n "$git_email" ]; then
            echo "Grudgingly-Disapproved-By: $git_name <$git_email>"
        else
            echo "Grudgingly-Disapproved-By: Unknown User <unknown@example.com>"
        fi
    else
        if [ -n "$git_name" ] && [ -n "$git_email" ]; then
            echo "Signed-off-by: $git_name <$git_email>"
        else
            echo "Signed-off-by: Unknown User <unknown@example.com>"
        fi
    fi
}

# Function to show files that would be added
show_files_to_add() {
    local add_type="$1"

    echo "Files that would be added:" >&2

    if [ "$add_type" = "all" ]; then
        "$GIT_BIN" status --porcelain 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  $filename" >&2
            fi
        done
    else
        "$GIT_BIN" status --porcelain . 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  $filename" >&2
            fi
        done
    fi

    echo "" >&2
    echo "Instead, add files individually:" >&2

    if [ "$add_type" = "all" ]; then
        "$GIT_BIN" status --porcelain 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  git add $(printf '%q' "$filename")" >&2
            fi
        done
    else
        "$GIT_BIN" status --porcelain . 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  git add $(printf '%q' "$filename")" >&2
            fi
        done
    fi
}

# Check if this is an add command and we're in an AI context
if [ "$1" = "add" ]; then
    ai_tool=$(detect_ai_tool)

    if [ "$ai_tool" != "none" ]; then
        has_separator=false
        has_files_after_separator=false
        separator_found=false

        for arg in "$@"; do
            if [ "$separator_found" = true ]; then
                has_files_after_separator=true
                break
            elif [ "$arg" = "--" ]; then
                has_separator=true
                separator_found=true
            fi
        done

        for arg in "$@"; do
            if [ "$arg" = "-A" ] || [ "$arg" = "--all" ]; then
                if [ "$has_separator" = true ] && [ "$has_files_after_separator" = true ]; then
                    continue
                else
                    echo "Error: 'git add $arg' is not allowed when running under AI control ($ai_tool)." >&2
                    echo "For safety, AI tools must add files individually by specifying each file path." >&2
                    echo "" >&2
                    show_files_to_add "all"
                    echo "" >&2
                    echo "Or use: git add $arg -- specific-file" >&2
                    exit 1
                fi
            elif [ "$arg" = "." ]; then
                echo "Error: 'git add $arg' is not allowed when running under AI control ($ai_tool)." >&2
                echo "For safety, AI tools must add files individually by specifying each file path." >&2
                echo "" >&2
                show_files_to_add "current"
                exit 1
            fi
        done
    fi

    exec "$GIT_BIN" "$@"
fi

# Check if this is a commit command
if [ "$1" = "commit" ]; then
    ai_tool=$(detect_ai_tool)

    if [ "$ai_tool" != "none" ]; then
        has_no_verify=false
        has_lazy_cheater_flag=false

        for arg in "$@"; do
            if [ "$arg" = "--no-verify" ] || [ "$arg" = "-n" ]; then
                has_no_verify=true
            elif [ "$arg" = "--${ai_tool}-is-a-lazy-cheater" ]; then
                has_lazy_cheater_flag=true
            fi
        done

        if [ "$has_no_verify" = true ] && [ "$has_lazy_cheater_flag" = false ]; then
            echo "Error: '$ai_tool' is trying to bypass commit hooks with --no-verify!" >&2
            echo "This is not allowed for AI tools as it circumvents important safety checks." >&2
            echo "" >&2
            echo "If you really need to bypass hooks, add the flag: --${ai_tool}-is-a-lazy-cheater" >&2
            echo "This will publicly shame the AI for being lazy about following proper procedures." >&2
            exit 1
        fi
    fi

    # Build git command with appropriate author settings
    case "$ai_tool" in
        "codex")
            extra_args=(-c "user.name=Codex CLI" -c "user.email=noreply@openai.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "aider")
            extra_args=(-c "user.name=Aider" -c "user.email=aider@aider.chat" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "gemini")
            extra_args=(-c "user.name=Gemini" -c "user.email=noreply@google.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "qwen")
            extra_args=(-c "user.name=Qwen Code" -c "user.email=noreply@alibaba.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "claude")
            extra_args=(-c "user.name=Claude Code" -c "user.email=noreply@anthropic.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "zed")
            extra_args=(-c "user.name=Zed AI" -c "user.email=noreply@zed.dev" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "opencode")
            extra_args=(-c "user.name=opencode AI" -c "user.email=noreply@opencode.ai" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "cursor")
            extra_args=(-c "user.name=Cursor AI" -c "user.email=cursoragent@cursor.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "copilot")
            extra_args=(-c "user.name=GitHub Copilot" -c "user.email=copilot@github.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "droid")
            extra_args=(-c "user.name=Droid" -c "user.email=droid@factory.ai" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "amp")
            extra_args=(-c "user.name=Amp" -c "user.email=noreply@sourcegraph.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "kimi")
            extra_args=(-c "user.name=Kimi CLI" -c "user.email=noreply@kimi.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "openhands")
            extra_args=(-c "user.name=OpenHands" -c "user.email=openhands@all-hands.dev" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "crush")
            extra_args=(-c "user.name=Crush" -c "user.email=crush@charm.land" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "goose")
            extra_args=(-c "user.name=Goose User" -c "user.email=goose@opensource.block.xyz" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "cline")
            extra_args=(-c "user.name=Cline" -c "user.email=cline@cline.bot" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "roo")
            extra_args=(-c "user.name=Roo Code" -c "user.email=roo@roocode.dev" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        "windsurf")
            extra_args=(-c "user.name=Windsurf Cascade" -c "user.email=cascade@codeium.com" -c "commit.gpgsign=false")
            signoff=$(get_git_signoff $([ "$has_lazy_cheater_flag" = true ] && echo "disapprove"))
            ;;
        *)
            exec "$GIT_BIN" "$@"
            ;;
    esac

    shift  # Remove "commit" from arguments

    commit_args=()
    message_found=false
    skip_next=false

    for arg in "$@"; do
        if [ "$ai_tool" != "none" ] && [ "$arg" = "--${ai_tool}-is-a-lazy-cheater" ]; then
            continue
        fi

        if [ "$skip_next" = true ]; then
            if [ "$ai_tool" != "none" ] && [ "$has_lazy_cheater_flag" = true ]; then
                commit_args+=("$arg

ðŸ¤– SHAME: This commit was made by $ai_tool who was too lazy to fix the commit hooks properly.")
            else
                commit_args+=("$arg")
            fi
            commit_args+=(-m "$signoff")
            skip_next=false
            message_found=true
        elif [ "$arg" = "-m" ] || [ "$arg" = "--message" ]; then
            commit_args+=("$arg")
            skip_next=true
        else
            commit_args+=("$arg")
        fi
    done

    if [ "$message_found" = false ]; then
        tmpfile=$(mktemp)
        if [ "$ai_tool" != "none" ] && [ "$has_lazy_cheater_flag" = true ]; then
            echo "

ðŸ¤– SHAME: This commit was made by $ai_tool who was too lazy to fix the commit hooks properly." >> "$tmpfile"
        fi
        echo "" >> "$tmpfile"
        [ "$has_lazy_cheater_flag" = true ] && signoff=$(get_git_signoff "disapprove")
        echo "$signoff" >> "$tmpfile"
        commit_args+=(--template "$tmpfile")

        "$GIT_BIN" "${extra_args[@]}" commit "${commit_args[@]}"
        exit_code=$?
        rm -f "$tmpfile"
        exit $exit_code
    else
        exec "$GIT_BIN" "${extra_args[@]}" commit "${commit_args[@]}"
    fi
else
    exec "$GIT_BIN" "$@"
fi

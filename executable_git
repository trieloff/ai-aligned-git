#!/bin/bash

# Git wrapper - Automatically detect AI tools and use appropriate commit attribution
# Uses am-i-ai shared detection library
# See: https://github.com/trieloff/am-i-ai

# --- BEGIN BUNDLED am-i-ai ---
# Bundled from am-i-ai v1.1.0
# https://github.com/trieloff/am-i-ai
#
# This code is auto-generated. Do not edit manually.
# To update, run the propagate-updates workflow in am-i-ai.

_ami_debug() {
    if [ "$AMI_DEBUG" = "true" ]; then
        echo "[am-i-ai] $*" >&2
    fi
}
ami_process_contains() {
    local pid=$1
    local pattern=$2

    # Get process command and name
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o command= 2>/dev/null | grep -qi "$pattern"
    else
        # Linux
        ps -p "$pid" -o comm= 2>/dev/null | grep -qi "$pattern" || \
        ps -p "$pid" -o cmd= 2>/dev/null | grep -qi "$pattern"
    fi
}
ami_check_env() {
    local detected=""

    # Claude Code detection
    # Detect via CLAUDECODE or CLAUDE_CODE_ENTRYPOINT env vars
    # ACP mode sets CLAUDECODE=1 without CLAUDE_CODE_ENTRYPOINT
    # CLI/SDK mode sets both CLAUDECODE and CLAUDE_CODE_ENTRYPOINT
    if [ -n "$CLAUDECODE" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "cli" ] || [ "$CLAUDE_CODE_ENTRYPOINT" = "sdk-ts" ]; then
        detected="$detected claude"
        _ami_debug "Detected Claude via environment variable"
    fi

    # Gemini detection
    if [ -n "$GEMINI_CLI" ]; then
        detected="$detected gemini"
        _ami_debug "Detected Gemini via environment variable"
    fi

    # Qwen detection
    if [ -n "$QWEN_CODE" ]; then
        detected="$detected qwen"
        _ami_debug "Detected Qwen via environment variable"
    fi

    # Cursor detection - use CURSOR_AGENT to avoid false positives in Cursor IDE terminals
    if [ -n "$CURSOR_AGENT" ]; then
        detected="$detected cursor"
        _ami_debug "Detected Cursor via environment variable"
    fi

    # OpenCode detection
    if [ -n "$OPENCODE_AI" ]; then
        detected="$detected opencode"
        _ami_debug "Detected OpenCode via environment variable"
    fi

    # Codex CLI detection
    # Detect via CODEX_CLI env var or CODEX_SANDBOX (set in sandboxed ACP sessions)
    if [ -n "$CODEX_CLI" ] || [ -n "$CODEX_SANDBOX" ]; then
        detected="$detected codex"
        _ami_debug "Detected Codex via environment variable"
    fi

    # Aider detection
    if [ "$OR_APP_NAME" = "Aider" ]; then
        detected="$detected aider"
        _ami_debug "Detected Aider via environment variable"
    fi

    # Zed detection - complex logic to distinguish human from AI
    # Observed patterns:
    # 1. Human via git panel: ZED_ENVIRONMENT + NO terminal vars + SHLVL=1
    # 2. Human via terminal: ZED_ENVIRONMENT + parent is interactive shell (elvish, zsh, bash, fish)
    # 3. Zed's native agent: ZED_ENVIRONMENT + HAS terminal vars + SHLVL>1 + parent NOT interactive shell
    # 4. ACP integrations: Have their own tool markers (handled above)
    #
    # Key insight: If the direct parent process is an interactive shell,
    # the user is typing commands manually, not the Zed agent.
    local term_program_lower
    term_program_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
    if [ -n "$ZED_ENVIRONMENT" ]; then
        if { [ "$term_program_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
            # Has terminal vars and SHLVL>1 - could be agent or human in terminal
            # Check if parent process is an interactive shell (human typing)
            local parent_comm
            parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
            case "$parent_comm" in
                bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                    # Parent is interactive shell - human typing in terminal
                    _ami_debug "Zed detected but parent is interactive shell ($parent_comm) - human typing"
                    ;;
                *)
                    # Parent is not an interactive shell - likely Zed agent
                    detected="$detected zed"
                    _ami_debug "Detected Zed AI agent via environment (parent: $parent_comm)"
                    ;;
            esac
        fi
        # else: Human git panel (SHLVL=1, no terminal vars)
    fi

    # Copilot detection
    if [ "$GITHUB_COPILOT_CLI_MODE" = "true" ]; then
        detected="$detected copilot"
        _ami_debug "Detected Copilot via environment variable"
    fi

    # Droid detection (Factory AI)
    if [ -n "$DROID_CLI" ]; then
        detected="$detected droid"
        _ami_debug "Detected Droid via environment variable"
    fi

    # Amp detection (Sourcegraph)
    if [ "$AGENT" = "amp" ] || [ -n "$AMP_HOME" ]; then
        detected="$detected amp"
        _ami_debug "Detected Amp via environment variable"
    fi

    # Kimi CLI detection
    if [ -n "$KIMI_CLI" ]; then
        detected="$detected kimi"
        _ami_debug "Detected Kimi CLI via environment variable"
    fi

    # OpenHands detection
    if [ "$OR_APP_NAME" = "OpenHands" ] || [ -n "$OR_SITE_URL" ]; then
        detected="$detected openhands"
        _ami_debug "Detected OpenHands via environment variable"
    fi

    # Goose detection (Block)
    if [ -n "$GOOSE_TERMINAL" ]; then
        detected="$detected goose"
        _ami_debug "Detected Goose via environment variable"
    fi

    # Auggie detection (Augment Code)
    if [ -n "$AUGMENT_API_TOKEN" ]; then
        detected="$detected auggie"
        _ami_debug "Detected Auggie via environment variable"
    fi

    # Cline detection (VS Code extension)
    if [ -n "$CLINE_TASK_ID" ]; then
        detected="$detected cline"
        _ami_debug "Detected Cline via environment variable"
    fi

    # Roo Code detection (VS Code extension)
    if [ -n "$ROO_CODE_TASK_ID" ]; then
        detected="$detected roo"
        _ami_debug "Detected Roo Code via environment variable"
    fi

    # Windsurf/Cascade detection
    if [ -n "$WINDSURF_SESSION" ] || [ "$TERM_PROGRAM" = "windsurf" ]; then
        detected="$detected windsurf"
        _ami_debug "Detected Windsurf via environment variable"
    fi

    echo "$detected"
}
ami_check_ps_tree() {
    local detected=""
    local current_pid=$$
    local max_depth=10
    local depth=0

    _ami_debug "Starting process tree detection from PID $current_pid"

    while [ $depth -lt $max_depth ]; do
        # Get parent PID
        if [[ "$OSTYPE" == "darwin"* ]]; then
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        else
            current_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ')
        fi

        # Check if we've reached the top
        if [ -z "$current_pid" ] || [ "$current_pid" -eq 1 ] || [ "$current_pid" -eq 0 ]; then
            _ami_debug "Reached top of process tree at depth $depth"
            break
        fi

        _ami_debug "Checking PID $current_pid at depth $depth"

        # Check for AI tool patterns
        if ami_process_contains "$current_pid" "claude"; then
            detected="$detected claude"
            _ami_debug "Detected Claude in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "gemini"; then
            detected="$detected gemini"
            _ami_debug "Detected Gemini in process tree at depth $depth"
        fi
        # Detect Codex CLI by process name
        if ami_process_contains "$current_pid" "codex"; then
            detected="$detected codex"
            _ami_debug "Detected Codex in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "aider"; then
            detected="$detected aider"
            _ami_debug "Detected Aider in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "qwen"; then
            detected="$detected qwen"
            _ami_debug "Detected Qwen in process tree at depth $depth"
        fi
        if ami_process_contains "$current_pid" "zed"; then
            # Attribute to Zed's native agent when terminal vars ARE set and SHLVL > 1
            # BUT not if parent is an interactive shell (human typing)
            local tp_lower
            tp_lower=$(echo "$TERM_PROGRAM" | tr '[:upper:]' '[:lower:]')
            if { [ "$tp_lower" = "zed" ] || [ -n "$ZED_TERM" ]; } && [ "${SHLVL:-1}" -gt 1 ]; then
                local parent_comm
                parent_comm=$(ps -p "$PPID" -o comm= 2>/dev/null | tr '[:upper:]' '[:lower:]')
                case "$parent_comm" in
                    bash|elvish|zsh|fish|ksh|tcsh|dash|-bash|-elvish|-zsh|-fish|-ksh|-tcsh|-dash)
                        # Parent is interactive shell - human typing
                        _ami_debug "Zed in tree but parent is interactive shell - human typing"
                        ;;
                    *)
                        detected="$detected zed"
                        _ami_debug "Detected Zed AI in process tree at depth $depth"
                        ;;
                esac
            fi
        fi
        if ami_process_contains "$current_pid" "opencode"; then
            detected="$detected opencode"
            _ami_debug "Detected OpenCode in process tree at depth $depth"
        fi
        # Cursor detection - use cursor-agent to avoid false positives in Cursor IDE terminals
        if ami_process_contains "$current_pid" "cursor-agent"; then
            detected="$detected cursor"
            _ami_debug "Detected Cursor in process tree at depth $depth"
        fi
        # Kimi CLI detection - look for kimi in process command
        if ami_process_contains "$current_pid" "kimi"; then
            detected="$detected kimi"
            _ami_debug "Detected Kimi CLI in process tree at depth $depth"
        fi
        # Crush detection - look for crush in process command
        if ami_process_contains "$current_pid" "crush"; then
            detected="$detected crush"
            _ami_debug "Detected Crush in process tree at depth $depth"
        fi
        # Goose detection - look for goose in process command
        if ami_process_contains "$current_pid" "goose"; then
            detected="$detected goose"
            _ami_debug "Detected Goose in process tree at depth $depth"
        fi
        # Auggie detection - look for auggie in process command
        if ami_process_contains "$current_pid" "auggie"; then
            detected="$detected auggie"
            _ami_debug "Detected Auggie in process tree at depth $depth"
        fi
        # Cline detection
        if ami_process_contains "$current_pid" "cline"; then
            detected="$detected cline"
            _ami_debug "Detected Cline in process tree at depth $depth"
        fi
        # Roo Code detection - use word boundary to avoid matching "kangaroo", etc.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "roo" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "roo"; then
                detected="$detected roo"
                _ami_debug "Detected Roo Code in process tree at depth $depth"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "roo" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "roo"; then
                detected="$detected roo"
                _ami_debug "Detected Roo Code in process tree at depth $depth"
            fi
        fi
        # Windsurf detection
        if ami_process_contains "$current_pid" "windsurf"; then
            detected="$detected windsurf"
            _ami_debug "Detected Windsurf in process tree at depth $depth"
        fi
        # Droid detection - use word boundary to avoid matching android-studio, etc.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o command= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                _ami_debug "Detected Droid in process tree at depth $depth"
            fi
        else
            if ps -p "$current_pid" -o comm= 2>/dev/null | grep -qiw "droid" || \
               ps -p "$current_pid" -o cmd= 2>/dev/null | grep -qiw "droid"; then
                detected="$detected droid"
                _ami_debug "Detected Droid in process tree at depth $depth"
            fi
        fi

        depth=$((depth + 1))
    done

    echo "$detected"
}
ami_detect() {
    _ami_debug "Starting AI detection"

    # Phase 1: Environment variable detection
    local env_detected
    env_detected=$(ami_check_env)

    # Phase 2: Process tree detection
    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    # Combine results and apply priority order
    local all_detected="$env_detected $ps_detected"

    _ami_debug "Environment detected: '$env_detected'"
    _ami_debug "Process tree detected: '$ps_detected'"
    _ami_debug "Combined detected: '$all_detected'"

    # Priority order: Amp > Codex > Aider > Claude > Gemini > Qwen > Droid > OpenCode > Cursor > Copilot > Kimi > OpenHands > Cline > Roo > Windsurf > Crush > Goose > Auggie > Zed
    # Zed is last because it often hosts other AI tools
    # More specific AI tools take precedence over IDE-level tools
    if [[ "$all_detected" =~ "amp" ]]; then
        _ami_debug "Final result: amp"
        echo "amp"
    elif [[ "$all_detected" =~ "codex" ]]; then
        _ami_debug "Final result: codex"
        echo "codex"
    elif [[ "$all_detected" =~ "aider" ]]; then
        _ami_debug "Final result: aider"
        echo "aider"
    elif [[ "$all_detected" =~ "claude" ]]; then
        _ami_debug "Final result: claude"
        echo "claude"
    elif [[ "$all_detected" =~ "gemini" ]]; then
        _ami_debug "Final result: gemini"
        echo "gemini"
    elif [[ "$all_detected" =~ "qwen" ]]; then
        _ami_debug "Final result: qwen"
        echo "qwen"
    elif [[ "$all_detected" =~ "droid" ]]; then
        _ami_debug "Final result: droid"
        echo "droid"
    elif [[ "$all_detected" =~ "opencode" ]]; then
        _ami_debug "Final result: opencode"
        echo "opencode"
    elif [[ "$all_detected" =~ "cursor" ]]; then
        _ami_debug "Final result: cursor"
        echo "cursor"
    elif [[ "$all_detected" =~ "copilot" ]]; then
        _ami_debug "Final result: copilot"
        echo "copilot"
    elif [[ "$all_detected" =~ "kimi" ]]; then
        _ami_debug "Final result: kimi"
        echo "kimi"
    elif [[ "$all_detected" =~ "openhands" ]]; then
        _ami_debug "Final result: openhands"
        echo "openhands"
    elif [[ "$all_detected" =~ "cline" ]]; then
        _ami_debug "Final result: cline"
        echo "cline"
    elif [[ "$all_detected" =~ "roo" ]]; then
        _ami_debug "Final result: roo"
        echo "roo"
    elif [[ "$all_detected" =~ "windsurf" ]]; then
        _ami_debug "Final result: windsurf"
        echo "windsurf"
    elif [[ "$all_detected" =~ "crush" ]]; then
        _ami_debug "Final result: crush"
        echo "crush"
    elif [[ "$all_detected" =~ "goose" ]]; then
        _ami_debug "Final result: goose"
        echo "goose"
    elif [[ "$all_detected" =~ "auggie" ]]; then
        _ami_debug "Final result: auggie"
        echo "auggie"
    elif [[ "$all_detected" =~ "zed" ]]; then
        _ami_debug "Final result: zed"
        echo "zed"
    else
        _ami_debug "Final result: none"
        echo "none"
    fi
}
ami_is_ai() {
    local result
    result=$(ami_detect)
    [ "$result" != "none" ]
}
ami_detect_all() {
    local env_detected
    env_detected=$(ami_check_env)

    local ps_detected
    ps_detected=$(ami_check_ps_tree)

    # Combine and deduplicate
    local all_detected="$env_detected $ps_detected"

    # Remove leading/trailing spaces and deduplicate
    echo "$all_detected" | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//'
}
ami_get_email() {
    local tool="${1:-$(ami_detect)}"

    case "$tool" in
        "claude")   echo "noreply@anthropic.com" ;;
        "gemini")   echo "noreply@google.com" ;;
        "codex")    echo "noreply@openai.com" ;;
        "aider")    echo "aider@aider.chat" ;;
        "qwen")     echo "noreply@alibaba.com" ;;
        "cursor")   echo "cursoragent@cursor.com" ;;
        "opencode") echo "noreply@opencode.ai" ;;
        "zed")      echo "noreply@zed.dev" ;;
        "copilot")  echo "copilot@github.com" ;;
        "droid")    echo "droid@factory.ai" ;;
        "amp")      echo "noreply@sourcegraph.com" ;;
        "kimi")     echo "noreply@kimi.com" ;;
        "openhands") echo "openhands@all-hands.dev" ;;
        "crush")    echo "crush@charm.land" ;;
        "goose")    echo "goose@opensource.block.xyz" ;;
        "auggie")   echo "noreply@augmentcode.com" ;;
        "cline")    echo "cline@cline.bot" ;;
        "roo")      echo "roo@roocode.dev" ;;
        "windsurf") echo "cascade@codeium.com" ;;
        *)          echo "" ;;
    esac
}
ami_get_name() {
    local tool="${1:-$(ami_detect)}"

    case "$tool" in
        "claude")   echo "Claude Code" ;;
        "gemini")   echo "Gemini" ;;
        "codex")    echo "Codex CLI" ;;
        "aider")    echo "Aider" ;;
        "qwen")     echo "Qwen Code" ;;
        "cursor")   echo "Cursor AI" ;;
        "opencode") echo "opencode AI" ;;
        "zed")      echo "Zed AI" ;;
        "copilot")  echo "GitHub Copilot" ;;
        "droid")    echo "Droid" ;;
        "amp")      echo "Amp" ;;
        "kimi")     echo "Kimi CLI" ;;
        "openhands") echo "OpenHands" ;;
        "crush")    echo "Crush" ;;
        "goose")    echo "Goose User" ;;
        "auggie")   echo "Augment Code" ;;
        "cline")    echo "Cline" ;;
        "roo")      echo "Roo Code" ;;
        "windsurf") echo "Windsurf Cascade" ;;
        *)          echo "" ;;
    esac
}

# Function aliases for backward compatibility
process_contains() { ami_process_contains "$@"; }
check_env_vars() { ami_check_env; }
check_ps_tree() { ami_check_ps_tree; }
detect_ai_tool() { ami_detect; }
# --- END BUNDLED am-i-ai ---

# Find the real git executable
find_real_git() {
    # Common locations for git
    local git_paths=(
        "/usr/bin/git"
        "/usr/local/bin/git"
        "/opt/homebrew/bin/git"
        "/opt/local/bin/git"
    )

    for git_path in "${git_paths[@]}"; do
        if [ -x "$git_path" ]; then
            echo "$git_path"
            return
        fi
    done

    # If not found in common locations, search PATH excluding our own directory
    local our_dir
    our_dir=$(dirname "$0")
    local IFS=:
    for dir in $PATH; do
        if [ "$dir" != "$our_dir" ] && [ -x "$dir/git" ]; then
            echo "$dir/git"
            return
        fi
    done

    echo "git not found" >&2
    exit 1
}

# Main script
GIT_BIN=$(find_real_git)

# Function to get the human trailer for commit attribution
# Maps a vibe-level mode to the appropriate trailer key
get_human_trailer() {
    local mode="${1:-signoff}"  # "prompt" | "sign-off" | "signoff" | "co-author" | "disapprove"
    local git_name
    local git_email
    git_name=$("$GIT_BIN" config user.name 2>/dev/null)
    git_email=$("$GIT_BIN" config user.email 2>/dev/null)

    if [ -z "$git_name" ] || [ -z "$git_email" ]; then
        git_name="Unknown User"
        git_email="unknown@example.com"
    fi

    local trailer_key
    case "$mode" in
        prompt)
            trailer_key="Prompted-by"
            ;;
        co-author)
            trailer_key="Co-authored-by"
            ;;
        disapprove)
            trailer_key="Grudgingly-Disapproved-By"
            ;;
        sign-off|signoff|*)
            trailer_key="Signed-off-by"
            ;;
    esac

    echo "$trailer_key: $git_name <$git_email>"
}

# Check if the repository requires vibe-level disclosure
is_vibe_level_required() {
    "$GIT_BIN" config --get ai-aligned.disclose-vibe-level 2>/dev/null | grep -qi 'true'
}

# Check if the repository requires prompt disclosure
is_prompt_required() {
    "$GIT_BIN" config --get ai-aligned.require-prompt 2>/dev/null | grep -qi 'true'
}

# Function to show files that would be added
show_files_to_add() {
    local add_type="$1"  # "all" or "current"

    echo "Files that would be added:" >&2

    if [ "$add_type" = "all" ]; then
        # Show all modified, new, and deleted files (equivalent to git add -A)
        "$GIT_BIN" status --porcelain 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                # Extract filename (everything after the status codes)
                filename=$(echo "$line" | cut -c4-)
                echo "  $filename" >&2
            fi
        done
    else
        # Show files in current directory and subdirectories (equivalent to git add .)
        "$GIT_BIN" status --porcelain . 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                # Extract filename (everything after the status codes)
                filename=$(echo "$line" | cut -c4-)
                echo "  $filename" >&2
            fi
        done
    fi

    echo "" >&2
    echo "Instead, add files individually:" >&2

    # Show the command to add them individually
    if [ "$add_type" = "all" ]; then
        "$GIT_BIN" status --porcelain 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  git add $(printf '%q' "$filename")" >&2
            fi
        done
    else
        "$GIT_BIN" status --porcelain . 2>/dev/null | while IFS= read -r line; do
            if [ -n "$line" ]; then
                filename=$(echo "$line" | cut -c4-)
                echo "  git add $(printf '%q' "$filename")" >&2
            fi
        done
    fi
}

# Check if this is an add command and we're in an AI context
if [ "$1" = "add" ]; then
    # Detect AI tool
    ai_tool=$(detect_ai_tool)

    if [ "$ai_tool" != "none" ]; then
        # Check for dangerous add patterns
        # Look for -- separator to determine if files are explicitly specified
        has_separator=false
        has_files_after_separator=false
        separator_found=false

        for arg in "$@"; do
            if [ "$separator_found" = true ]; then
                # We found arguments after --, so files are explicitly specified
                has_files_after_separator=true
                break
            elif [ "$arg" = "--" ]; then
                has_separator=true
                separator_found=true
            fi
        done

        # Check each argument for dangerous patterns
        for arg in "$@"; do
            if [ "$arg" = "-A" ] || [ "$arg" = "--all" ]; then
                # Allow -A/--all if files are explicitly specified after --
                if [ "$has_separator" = true ] && [ "$has_files_after_separator" = true ]; then
                    continue  # This is safe: git add -A -- specific-file
                else
                    echo "Error: 'git add $arg' is not allowed when running under AI control ($ai_tool)." >&2
                    echo "For safety, AI tools must add files individually by specifying each file path." >&2
                    echo "" >&2
                    show_files_to_add "all"
                    echo "" >&2
                    echo "Or use: git add $arg -- specific-file" >&2
                    exit 1
                fi
            elif [ "$arg" = "." ]; then
                echo "Error: 'git add $arg' is not allowed when running under AI control ($ai_tool)." >&2
                echo "For safety, AI tools must add files individually by specifying each file path." >&2
                echo "" >&2
                show_files_to_add "current"
                exit 1
            fi
        done
    fi

    # If we get here, the add command is safe - pass through to regular git
    exec "$GIT_BIN" "$@"
fi

# Check if this is a commit command
if [ "$1" = "commit" ]; then
    # Detect AI tool
    ai_tool=$(detect_ai_tool)

    # Check for --no-verify bypass attempts by AI tools
    if [ "$ai_tool" != "none" ]; then
        has_no_verify=false
        has_lazy_cheater_flag=false
        has_amend=false
        vibe_level=""
        prompt_text=""
        grab_next_prompt=false

        for arg in "$@"; do
            if [ "$grab_next_prompt" = true ]; then
                prompt_text="$arg"
                grab_next_prompt=false
            elif [ "$arg" = "--no-verify" ] || [ "$arg" = "-n" ]; then
                has_no_verify=true
            elif [ "$arg" = "--amend" ]; then
                has_amend=true
            elif [ "$arg" = "--${ai_tool}-is-a-lazy-cheater" ]; then
                has_lazy_cheater_flag=true
            elif [[ "$arg" == --vibe-level=* ]]; then
                vibe_level="${arg#--vibe-level=}"
                case "$vibe_level" in
                    prompt|co-author|sign-off|signoff) ;;
                    *)
                        echo "Error: Invalid --vibe-level value: '$vibe_level'." >&2
                        echo "Allowed values are: prompt, co-author, sign-off, signoff." >&2
                        exit 1
                        ;;
                esac
            elif [[ "$arg" == --prompt=* ]]; then
                prompt_text="${arg#--prompt=}"
            elif [ "$arg" = "--prompt" ]; then
                grab_next_prompt=true
            fi
        done

        # Check for dangling --prompt flag (no value provided)
        if [ "$grab_next_prompt" = true ]; then
            echo "Error: --prompt flag requires a value." >&2
            echo "Usage: --prompt \"description\" or --prompt=\"description\"" >&2
            exit 1
        fi

        # Reject --prompt with --amend as it changes semantics
        if [ -n "$prompt_text" ] && [ "$has_amend" = true ]; then
            echo "Error: --prompt cannot be used with --amend." >&2
            echo "The --prompt flag creates a new commit before your code commit," >&2
            echo "which conflicts with --amend's intent to modify the previous commit." >&2
            exit 1
        fi

        # --prompt implies --vibe-level=prompt when no explicit --vibe-level
        if [ -n "$prompt_text" ] && [ -z "$vibe_level" ]; then
            vibe_level="prompt"
        fi

        if [ "$has_no_verify" = true ] && [ "$has_lazy_cheater_flag" = false ]; then
            echo "Error: '$ai_tool' is trying to bypass commit hooks with --no-verify!" >&2
            echo "This is not allowed for AI tools as it circumvents important safety checks." >&2
            echo "" >&2
            echo "If you really need to bypass hooks, add the flag: --${ai_tool}-is-a-lazy-cheater" >&2
            echo "This will publicly shame the AI for being lazy about following proper procedures." >&2
            exit 1
        fi

        # Enforce vibe-level disclosure if required by config
        if is_vibe_level_required && [ -z "$vibe_level" ] && [ "$has_lazy_cheater_flag" = false ]; then
            echo "Error: This repository requires disclosure of the AI collaboration level." >&2
            echo "Please add --vibe-level=<level> to your commit command." >&2
            echo "" >&2
            echo "Available levels:" >&2
            echo "  prompt     - You (the AI) autonomously wrote this code based on a human prompt." >&2
            echo "               The human described what they wanted; you decided how to build it." >&2
            echo "  co-author  - You and the human collaborated on this code together." >&2
            echo "               Both contributed ideas and implementation decisions." >&2
            echo "  sign-off   - The human wrote this code; you helped review, refine, or debug it." >&2
            echo "               The human made the key decisions; you assisted." >&2
            echo "" >&2
            echo "Example: git commit -m \"Fix bug\" --vibe-level=co-author" >&2
            exit 1
        fi

        # Enforce prompt disclosure if required by config
        if is_prompt_required && [ -z "$prompt_text" ]; then
            echo "Error: This repository requires AI commits to include a prompt summary." >&2
            echo "The --prompt flag records what you were asked to do, creating a" >&2
            echo "human-attributed commit that links your work to the original request." >&2
            echo "" >&2
            echo "Example: git commit -m \"Add login page\" --prompt \"Build a login page with email and password fields\"" >&2
            exit 1
        fi

        # If no --prompt and enforcement is off, print a reminder
        if [ -z "$prompt_text" ] && ! is_prompt_required; then
            echo "Tip: You can include a prompt summary with --prompt \"what you were asked to do\"" >&2
        fi
    fi

    # Build git command with appropriate author settings using am-i-ai library
    # This automatically supports all AI tools defined in am-i-ai
    ai_name=$(ami_get_name "$ai_tool")
    ai_email=$(ami_get_email "$ai_tool")

    if [ -n "$ai_name" ] && [ -n "$ai_email" ]; then
        extra_args=(
            -c "user.name=$ai_name"
            -c "user.email=$ai_email"
            -c "commit.gpgsign=false"
        )
        # Determine the trailer based on vibe-level or lazy cheater flag
        if [ "$has_lazy_cheater_flag" = true ]; then
            trailer=$(get_human_trailer "disapprove")
        elif [ -n "$vibe_level" ]; then
            trailer=$(get_human_trailer "$vibe_level")
        else
            trailer=$(get_human_trailer "signoff")
        fi
    else
        # Unknown AI tool or no attribution info - pass through to regular git
        exec "$GIT_BIN" "$@"
    fi

    # If we detected an AI tool, we need to handle the commit specially
    shift  # Remove "commit" from arguments

    # Parse commit arguments, stripping custom flags git doesn't understand
    commit_args=()
    message_found=false
    skip_next=false
    skip_next_for_prompt=false

    for arg in "$@"; do
        # Skip the value after --prompt (space-separated form)
        if [ "$skip_next_for_prompt" = true ]; then
            skip_next_for_prompt=false
            continue
        fi

        # Skip the lazy cheater flag - git doesn't understand it
        if [ "$ai_tool" != "none" ] && [ "$arg" = "--${ai_tool}-is-a-lazy-cheater" ]; then
            continue
        fi

        # Skip --vibe-level flag - git doesn't understand it
        if [[ "$arg" == --vibe-level=* ]]; then
            continue
        fi

        # Skip --prompt flag - git doesn't understand it
        if [[ "$arg" == --prompt=* ]]; then
            continue
        fi
        if [ "$arg" = "--prompt" ]; then
            skip_next_for_prompt=true
            continue
        fi

        if [ "$skip_next" = true ]; then
            # This is the message content after -m
            if [ "$ai_tool" != "none" ] && [ "$has_lazy_cheater_flag" = true ]; then
                commit_args+=("$arg

ðŸ¤– SHAME: This commit was made by $ai_tool who was too lazy to fix the commit hooks properly.")
            else
                commit_args+=("$arg")
            fi
            skip_next=false
            message_found=true
        elif [ "$arg" = "-m" ] || [ "$arg" = "--message" ]; then
            commit_args+=("$arg")
            skip_next=true
        else
            commit_args+=("$arg")
        fi
    done

    # Append --trailer for human attribution (works with both -m and editor modes)
    commit_args+=(--trailer "$trailer")

    # If --prompt is set, create an empty commit attributed to the human
    # Uses a temporary index to avoid consuming the staging area
    if [ -n "$prompt_text" ]; then
        human_name=$("$GIT_BIN" config user.name 2>/dev/null)
        human_email=$("$GIT_BIN" config user.email 2>/dev/null)
        if [ -z "$human_name" ]; then human_name="Unknown User"; fi
        if [ -z "$human_email" ]; then human_email="unknown@example.com"; fi

        # Create empty commit using a temporary index so staged changes are preserved
        tmp_index=$(mktemp -u)  # -u creates name only, no file
        # Copy current HEAD tree into the temp index so the commit is truly empty
        if ! GIT_INDEX_FILE="$tmp_index" "$GIT_BIN" read-tree HEAD 2>/dev/null; then
            echo "Error: Failed to prepare prompt commit (read-tree failed)." >&2
            exit 1
        fi
        if ! GIT_INDEX_FILE="$tmp_index" "$GIT_BIN" commit --allow-empty -m "prompt($ai_tool): $prompt_text" --author="$human_name <$human_email>"; then
            rm -f "$tmp_index"
            echo "Error: Failed to create prompt commit. Aborting." >&2
            exit 1
        fi
        rm -f "$tmp_index"
    fi

    # If no -m message was provided and lazy cheater flag is set,
    # use a template to inject the SHAME body text for the editor
    if [ "$message_found" = false ] && [ "$has_lazy_cheater_flag" = true ]; then
        tmpfile=$(mktemp)
        echo "
ðŸ¤– SHAME: This commit was made by $ai_tool who was too lazy to fix the commit hooks properly." >> "$tmpfile"
        commit_args+=(--template "$tmpfile")

        # Run git commit and clean up
        "$GIT_BIN" "${extra_args[@]}" commit "${commit_args[@]}"
        exit_code=$?
        rm -f "$tmpfile"
        exit $exit_code
    else
        # Run git commit with trailer appended
        exec "$GIT_BIN" "${extra_args[@]}" commit "${commit_args[@]}"
    fi
else
    # Not a commit command, pass through to regular git
    exec "$GIT_BIN" "$@"
fi
